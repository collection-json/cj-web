<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.4" />
<title>Collection+JSON Tutorials</title>
<style type="text/css">
/* Sans-serif font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
div#toctitle,
span#author, span#revnumber, span#revdate, span#revremark,
div#footer {
  font-family: Arial,Helvetica,sans-serif;
}

/* Serif font. */
div.sectionbody {
  font-family: Georgia,"Times New Roman",Times,serif;
}

/* Monospace font. */
tt {
  font-size: inherit;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

tt {
  font-size: inherit;
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revnumber, span#revdate, span#revremark {
}

div#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  div#footer-badges { display: none; }
}

div#toc {
  margin-bottom: 2.5em;
}

div#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }
</style>
<script type="text/javascript">
/*<![CDATA[*/
window.onload = function(){asciidoc.footnotes();}
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([2-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  var cont = document.getElementById("content");
  var noteholder = document.getElementById("footnotes");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      // Use [\s\S] in place of . so multi-line matches work.
      // Because JavaScript has no s (dotall) regex flag.
      note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      spans[i].innerHTML =
        "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
        "' title='View footnote' class='footnote'>" + n + "</a>]";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
}

}
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Collection+JSON Tutorials</h1>
<span id="author">Mike Amundsen</span><br />
<span id="email"><tt>&lt;<a href="mailto:mamund@yahoo.com">mamund@yahoo.com</a>&gt;</tt></span><br />
</div>
<div id="content">
<div class="sect1">
<h2 id="_generating_a_cj_response_from_a_server">Generating a Cj Response from a Server</h2>
<div class="sectionbody">
<div class="paragraph"><p>In this short tutorial you&#8217;ll get a <em>walk-through</em> (in nodejs) of how to
generate a valid Collection+JSON (Cj) response from a server. This is a
very simple example that leaves out a number of functional elements of the
server in order to focus on the process of generating a valid Cj response.
This tutorial takes you through five steps to crafting a valid Cj response
from a server. Actually, there are four basic steps and one added section
that covers how to communicate error details to client apps.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>This tutorial does not cover how a client application accepts and processes a Cj response. This tutorial only
covers the basics of generating valid Cj responses from a <em>server</em>. Details on client-side processing of Cj
responses will be covered in another tutorial.</p></div>
</td>
</tr></table>
</div>
<div class="sect2">
<h3 id="_before_we_get_started">Before We Get Started</h3>
<div class="paragraph"><p>First, since this tutorial is written in <a href="http://nodejs.org">nodejs</a>, there is a bit
of housekeeping code that is needed to get the project up and running. Below
is a shell script that handles the basics of a small nodejs server application.</p></div>
<div class="listingblock">
<div class="title">NodeJS Project Shell</div>
<div class="content">
<pre><tt>var url = require('url');
var http = require('http');
var port = process.env.PORT||1337;


var path = '';
var base = '';
var cType = 'application/vnd.collection+json';
var cj = {};
var friends = [];
var pathfilter = '/favicon.ico /sortbyemail /sortbyname /filterbyname';

function handler(req, res) {
    base = 'http://' + req.headers.host;
    path = url.parse(req.url).pathname;
    if(pathfilter.indexOf(path)!==-1) {
        path = '/';
    }

    res.writeHead(200, 'OK', {'content-type':cType});
    res.end(JSON.stringify(cj));
}

http.createServer(handler).listen(port);</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>Note that the
content-type (<tt>cType</tt>) value is set to <tt>application/vnd.collection+json</tt>. This is the media type identifier
for Collection+JSON registered with the <a href="http://www.iana.org/assignments/media-types/application/vnd.collection+json">IANA</a>.
Servers should always output valid Cj resaponses using this content-type identifier.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>The code above sets up a listener on the available port and responds with an empty object for now.</p></div>
<div class="sect3">
<h4 id="_adding_some_friends">Adding some Friends</h4>
<div class="paragraph"><p>The next step is to get some data to work with. For our example, we&#8217;ll use a list of friends (name, email, and blog address).
To keep things simple, we&#8217;ll store the friends in memory. Usually this kind of data would be in some external
storage such as a file system, local database or remote store. But, in our case, the in-memory data will work
just fine.</p></div>
<div class="paragraph"><p>Below is the added function (<tt>getFriends</tt>) that loads the data into memory and the modified <tt>handler</tt> routine
that makes the call to <tt>getFriends</tt> when the listener starts up.</p></div>
<div class="listingblock">
<div class="title">Adding Friends</div>
<div class="content">
<pre><tt>var url = require('url');
var http = require('http');
var port = process.env.PORT||1337;

var path = '';
var base = '';
var cType = 'application/vnd.collection+json';
var cj = {};
var friends = [];
var pathfilter = '/favicon.ico /sortbyemail /sortbyname /filterbyname';

function handler(req, res) {
    base = 'http://' + req.headers.host;
    path = url.parse(req.url).pathname;
    if(pathfilter.indexOf(path)!==-1) {
        path = '/';
    }

    getFriends();

    res.writeHead(200, 'OK', {'content-type':cType});
    res.end(JSON.stringify(cj));
}

// actual data to render
// usually kept in external storage
function getFriends() {
    var item = {};

    friends = [];

    item = {};
    item.name = 'mildred';
    item.email = 'mildred@example.com';
    item.blog = 'http://example.com/blogs/mildred';
    friends.push(item);

    item = {};
    item.name = 'mike';
    item.email = 'mike@example.com';
    item.blog = 'http://example.com/blogs/mike';
    friends.push(item);

    item = {};
    item.name = 'mary';
    item.email = 'mary@example.com';
    item.blog = 'http://example.com/blogs/mary';
    friends.push(item);

    item = {};
    item.name = 'mark';
    item.email = 'mark@example.com';
    item.blog = 'http://example.com/blogs/mark';
    friends.push(item);

    item = {};
    item.name = 'muffin';
    item.email = 'muffin@example.com';
    item.blog = 'http://example.com/blogs/muffin';
    friends.push(item);
}

http.createServer(handler).listen(port);</tt></pre>
</div></div>
<div class="paragraph"><p>Now we have enough starter material in nodejs to focus on the Cj-specific aspects of this tutorial. The creation of
a valid Cj response skeleton, rendering data as valid Cj <tt>items</tt>, and the optional rendering of <tt>queries</tt> and a
<tt>template</tt>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_part_1_the_cj_skeleton">Part 1: The Cj Skeleton</h3>
<div class="paragraph"><p>While it&#8217;s not a requirement, setting up the basic <em>skeleton</em> of a valid Cj response is a good idea.
This is the output that is used for every Cj response and will come in handy as a guide or starter template when responding to requests.</p></div>
<div class="paragraph"><p>Refering to the <a href="http://amundsen.com/media-types/collection/format/#objects-collection">Collection+JSON documentation</a>,
you can see the standard response contains a couple properties (<tt>href</tt> and <tt>version</tt>) and one or more additional arrays (<tt>links</tt>, <tt>items</tt>, and <tt>queries</tt>) or objects (<tt>template</tt>, <tt>error</tt>).</p></div>
<div class="listingblock">
<div class="title">Format of Collection+JSON Responses</div>
<div class="content">
<pre><tt>// sample collection object
{
  "collection" :
  {
    "version" : "1.0",
    "href" : URI,
    "links" : [ARRAY],
    "items" : [ARRAY],
    "queries" : [ARRAY],
    "template" : {OBJECT},
    "error" : {OBJECT}
  }
}</tt></pre>
</div></div>
<div class="paragraph"><p>We&#8217;ll got through all of these in this tutorial. But for this section, we&#8217;ll build up a simple skeleton of these
elements to use as a <em>starter</em> when generating responses. Below is a single method that creates this skeleton.</p></div>
<div class="listingblock">
<div class="title">Creating a Cj Response Skeleton</div>
<div class="content">
<pre><tt>// the basic template for all Cj responses
function createCjTemplate() {
    cj.collection = {};
    cj.collection.version = "1.0";
    cj.collection.href = base + path;

    cj.collection.links = [];
    cj.collection.links.push({'rel':'home', 'href' : base});

    cj.collection.items = [];
    cj.collection.queries = [];
    cj.collection.template = {};
}</tt></pre>
</div></div>
<div class="paragraph"><p>Then we add the <tt>createCjTemplate</tt> call to the <tt>handler</tt> routine at the top of our program:</p></div>
<div class="listingblock">
<div class="title">Adding <tt>createCjTemplate</tt> to the <tt>handler</tt> Routine</div>
<div class="content">
<pre><tt>function handler(req, res) {
    base = 'http://' + req.headers.host;
    path = url.parse(req.url).pathname;
    if(pathfilter.indexOf(path)!==-1) {
        path = '/';
    }

    getFriends();
    createCjTemplate();

    res.writeHead(200, 'OK', {'content-type':cType});
    res.end(JSON.stringify(cj));
}</tt></pre>
</div></div>
<div class="paragraph"><p>And, when the server is running, the response looks like this:</p></div>
<div class="listingblock">
<div class="title">Server Response for Cj Skeleton</div>
<div class="content">
<pre><tt>200 OK HTTP/1.1
Content-Type: application/vnd.collection+json
Length: XXX

{
  collection: {
    version: "1.0",
    href: "http://localhost:1337/",
    links: [
      {
        rel: "home",
        href: "http://localhost:1337"
      }
    ],
    items: [],
    queries: [],
    template: {}
  }
}</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>The use of the <tt><em>home</em></tt> link relation is not required by the Cj sepcifications, but it is a handy one to use. This
is a link that points to the root of the service. It allows client applications to locate the initial starting point
of the service not matter where they are in the workflow of any Cj application.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>So that&#8217;s a solid start. We have a server that returns a valid (but currently rather empty) Cj response whenever
a client make a request. Now it&#8217;s time to build up the rest of the representation.</p></div>
</div>
<div class="sect2">
<h3 id="_part_2_adding_items">Part 2: Adding Items</h3>
<div class="paragraph"><p>Once the basic skeleton is working, you can add items to the response
representation. Typically these are your primary data elements (or objects)
that you wish to return to the requesting client. It doesn&#8217;t matter how (or where)
this data is stored. It is the job of the server to take that data and
render it as valid Cj <tt>items</tt>.</p></div>
<div class="paragraph"><p>The most direct way to go about this is to gather up the data you wish to render (in our case this is the list
of friends) and "walk through" the list and add the properties to the Cj skeleton&#8217;s <tt>items</tt> array. The
<a href="http://amundsen.com/media-types/collection/format/#arrays-items">Cj documentation</a> says a single <tt>item</tt> looks like this:</p></div>
<div class="listingblock">
<div class="title">A Single Cj Item</div>
<div class="content">
<pre><tt>{
  "href" : URI,
  "data" : [ARRAY],
  "links" : [ARRAY]
}</tt></pre>
</div></div>
<div class="paragraph"><p>Each item as an <tt>href</tt> property and (optionally) an array of <tt>data</tt> elements and/or <tt>link</tt> elements. For our
example, we&#8217;ll render the <tt>name</tt> and <tt>email</tt> properties of our <tt>friends</tt> collection as Cj <tt>data</tt> elements and the
<tt>blog</tt> property as a Cj <tt>link</tt> element. Below is the method that handles this mapping of internal storage to
the Cj representation:</p></div>
<div class="listingblock">
<div class="title">Mapping Internal Storage to Cj Items</div>
<div class="content">
<pre><tt>// render data object (friends) as valid Cj items
function renderItems(coll) {
    var i, x, item, p, d, l;

    for(i=0, x=coll.length;i&lt;x;i++) {
        if(path==='/' || path==='/'+coll[i].name) {
            item = {};
            item.href = base + '/' + coll[i].name;
            item.data = [];
            item.links = [];

            d = 0;
            l = 0
            for(p in friends[i]) {
                if(p==='blog') {
                    item.links[l++] = {
                      'rel' : 'alternate',
                      'href' : friends[i][p],
                      'prompt' : p
                    }
                }
                else {
                    item.data[d++] = {
                        'name' : p,
                        'value' : friends[i][p],
                        'prompt' : p
                    }
                }
            }
            cj.collection.items.push(item);
        }
    }
}</tt></pre>
</div></div>
<div class="paragraph"><p>Next, all we need to do is add this function call to the top-level <tt>handler</tt> routine in our nodejs program:</p></div>
<div class="listingblock">
<div class="title">Adding <tt>renderItems</tt> to the <tt>handler</tt> Routine</div>
<div class="content">
<pre><tt>function handler(req, res) {
    base = 'http://' + req.headers.host;
    path = url.parse(req.url).pathname;
    if(pathfilter.indexOf(path)!==-1) {
        path = '/';
    }

    getFriends();
    createCjTemplate();

    renderItems();

    res.writeHead(200, 'OK', {'content-type':cType});
    res.end(JSON.stringify(cj));
}</tt></pre>
</div></div>
<div class="paragraph"><p>And now, when a client makes a request to the server, the response looks like this (abbreviated here to save space):</p></div>
<div class="listingblock">
<div class="title">Cj Response from Server with <tt>Items</tt></div>
<div class="content">
<pre><tt>200 OK HTTP/1.1
Content-Type: application/vnd.collection+json
Length: XXX

{
  collection: {
    version: "1.0",
    href: "http://localhost:1337/",
    links: [
      {
        rel: "home",
        href: "http://localhost:1337"
      }
    ],
    items: [
      {
        href: "http://localhost:1337/mildred",
        data: [
          {
            name: "name",
            value: "mildred",
            prompt: "name"
          },
          {
            name: "email",
            value: "mildred@example.com",
            prompt: "email"
          }
        ],
        links: [
          {
            rel: "alternate",
            href: "http://example.com/blogs/mildred",
            prompt: "blog"
          }
        ]
      },
      // more items go here...
    ],
    queries: [],
    template: {}
  }
}</tt></pre>
</div></div>
<div class="paragraph"><p>Now that we have the server rendering valid <tt>items</tt>, we can turn to some optional sections in a Cj response:
<tt>queries</tt> and the <tt>template</tt>.</p></div>
</div>
<div class="sect2">
<h3 id="_part_3_adding_queries">Part 3: Adding Queries</h3>
<div class="paragraph"><p>Optionally, you can add <tt>queries</tt> to your response. These are machine-readable
instructions on how a client application can fashion read-only query requests
and send them to the server. These instructions can be as simple as a <tt>rel</tt>
and <tt>href</tt> that the client app can acticvate. You can also describe more
involved queries by including a <tt>data</tt> array that describes individual query
parameters that clients can use when sending their request.</p></div>
<div class="paragraph"><p>For our example, let&#8217;s support three possible queries:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<strong>SortByName</strong> : This will return the <tt>items</tt> as a sorted list by the <tt>name</tt> property.
</p>
</li>
<li>
<p>
<strong>SortByEmail</strong> : This will return the <tt>items</tt> as a sorted list by the <tt>email</tt> property.
</p>
</li>
<li>
<p>
<strong>FilterByName</strong> : This will return a sub-set of the <tt>items</tt> based on a query parameter that matches the <tt>name</tt> property.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Now that we have that settled, we need to render that information in machine-readable form using the Cj <tt>queries</tt> section
of the response. Here&#8217;s the code that will handle that:</p></div>
<div class="listingblock">
<div class="title">Rendering Valid <tt>queries</tt> within a Cj Response</div>
<div class="content">
<pre><tt>// render supported queries as valid Cj query elements
function renderQueries() {
    var query = {};

    query = {};
    query.rel = 'collection sort';
    query.prompt = 'Sort by Name';
    query.href = base + '/sortbyname';
    cj.collection.queries.push(query);

    query = {};
    query.rel = 'collection filter';
    query.prompt = 'Filter by Name';
    query.href = base + '/filterbyname';
    query.data = [];
    query.data[0] = {
        'name' : 'name',
        'value' : '',
        'prompt' : 'Name'
    }
    cj.collection.queries.push(query);

    query = {};
    query.rel = 'collection sort';
    query.prompt = 'Sort by Email';
    query.href = base + '/sortbyemail';
    cj.collection.queries.push(query);
}</tt></pre>
</div></div>
<div class="paragraph"><p>And, of course, we need to add this call to the top-level <tt>handler</tt> routine:</p></div>
<div class="listingblock">
<div class="title">Adding the <tt>renderQueries</tt> call to the <tt>handler</tt> routine</div>
<div class="content">
<pre><tt>function handler(req, res) {
    base = 'http://' + req.headers.host;
    path = url.parse(req.url).pathname;
    if(pathfilter.indexOf(path)!==-1) {
        path = '/';
    }

    getFriends();
    createCjTemplate();

    renderItems();
    renderQueries();

    res.writeHead(200, 'OK', {'content-type':cType});
    res.end(JSON.stringify(cj));
}</tt></pre>
</div></div>
<div class="paragraph"><p>Now, when a client makes a request to the server, the response representation looks like this:</p></div>
<div class="listingblock">
<div class="title">Server Response including valid Cj Queries Section</div>
<div class="content">
<pre><tt>200 OK HTTP/1.1
Content-Type: application/vnd.collection+json
Length: XXX

{
  collection: {
    version: "1.0",
    href: "http://localhost:1337/",
    links: [
      {
        rel: "home",
        href: "http://localhost:1337"
      }
    ],
    items: [
      {
        href: "http://localhost:1337/mildred",
        data: [
          {
            name: "name",
            value: "mildred",
            prompt: "name"
          },
          {
            name: "email",
            value: "mildred@example.com",
            prompt: "email"
          }
        ],
        links: [
          {
            rel: "alternate",
            href: "http://example.com/blogs/mildred",
            prompt: "blog"
          }
        ]
      },
      /// more items go here...
    ],
    queries: [
      {
        rel: "collection sort",
        prompt: "Sort by Name",
        href: "http://localhost:1337/sortbyname"
      },
      {
        rel: "collection filter",
        prompt: "Filter by Name",
        href: "http://localhost:1337/filterbyname",
        data: [
          {
            name: "name",
            value: "",
            prompt: "Name"
          }
        ]
      },
      {
        rel: "collection sort",
        prompt: "Sort by Email",
        href: "http://localhost:1337/sortbyemail"
      }
    ],
    template: {}
  }
}</tt></pre>
</div></div>
<div class="paragraph"><p>Now our Cj response includes not just <tt>items</tt> but also machine-readable <tt>queries</tt> that clients can use to make additional
read-only requests to the server. But what if we want to tell clients that they can create new <tt>items</tt> and/or edit the
existing <tt>items</tt>? For that, we need to add a Write Template to the response.</p></div>
</div>
<div class="sect2">
<h3 id="_part_4_adding_a_write_template">Part 4: Adding a Write Template</h3>
<div class="paragraph"><p>Another optional portion of a valid Cj response is the <tt>template</tt> element. This is a machine-readable set of instructions
on how to craft a valid POST (create) or PUT (update) request to the server. The rules for writing data to servers using
Cj are very similar to the rules for the <a href="http://tools.ietf.org/html/rfc5023">Atom Publishling Protocol (RFC5023)</a>.
Essentially, there is an implicit agreement in Cj to support a CRUD-style (Create-Read-Update-Delete) pattern for any
<tt>items</tt> in a response. You can read up on the details in the
<a href="http://amundsen.com/media-types/collection/format/#general">General Concepts</a> section of the Cj documentation.</p></div>
<div class="paragraph"><p>For our example, we can add a <tt>template</tt> object to the response that provides a machine-readable description of how
client apps can fashion a request body that represents an <tt>item</tt> to add (POST) or update (PUT). In our case, we
want to tell clients they can write three values: <tt>name</tt>, <tt>email</tt>, and <tt>blog</tt>. Here&#8217;s the code that creates the
<tt>template</tt> object:</p></div>
<div class="listingblock">
<div class="title">Creating a <tt>template</tt> Object for a Cj Response</div>
<div class="content">
<pre><tt>// render write template (POST, PUT)
function renderTemplate() {
    var template = {};
    var item = {};

    template.data = [];

    item = {};
    item.name = 'name';
    item.value = '';
    item.prompt = 'Name';
    template.data.push(item);

    item = {};
    item.name = 'email';
    item.value = '';
    item.prompt = 'Email';
    template.data.push(item);

    item = {};
    item.name = 'blog';
    item.value = '';
    item.prompt= 'Blog';
    template.data.push(item);

    cj.collection.template = template;
}</tt></pre>
</div></div>
<div class="paragraph"><p>And then (as usual) we add the call to the <tt>renderTemplate</tt> method to the top-level <tt>handler</tt> routine:</p></div>
<div class="listingblock">
<div class="title">Adding the <tt>renderTemplate</tt> call to the <tt>hander</tt> routine:</div>
<div class="content">
<pre><tt>function handler(req, res) {
    base = 'http://' + req.headers.host;
    path = url.parse(req.url).pathname;
    if(pathfilter.indexOf(path)!==-1) {
        path = '/';
    }

    getFriends();

    createCjTemplate();
    renderItems(friends);
    renderQueries();
    renderTemplate();

    res.writeHead(200, 'OK', {'content-type':cType});
    res.end(JSON.stringify(cj));
}</tt></pre>
</div></div>
<div class="paragraph"><p>Now, when a client makes a request to the server, the response includes instructions on creating or updating <tt>items</tt></p></div>
<div class="listingblock">
<div class="title">Valid Cj Server Response that includes a <tt>template</tt> Object</div>
<div class="content">
<pre><tt>200 OK HTTP/1.1
Content-Type: application/vnd.collection+json
Length: XXX

{
  collection: {
    version: "1.0",
    href: "http://localhost:1337/",
    links: [
      {
        rel: "home",
        href: "http://localhost:1337"
      }
    ],
    items: [
      {
        href: "http://localhost:1337/mildred",
        data: [
          {
            name: "name",
            value: "mildred",
            prompt: "name"
          },
          {
            name: "email",
            value: "mildred@example.com",
            prompt: "email"
          }
        ],
        links: [
          {
            rel: "alternate",
            href: "http://example.com/blogs/mildred",
            prompt: "blog"
          }
        ]
      },
      // more items go here...
    ],
    queries: [
      // queries go here...
    ],
    template: {
      data: [
        {
          name: "name",
          value: "",
          prompt: "Name"
        },
        {
          name: "email",
          value: "",
          prompt: "Email"
        },
        {
          name: "blog",
          value: "",
          prompt: "Blog"
        }
      ]
    }
  }
}</tt></pre>
</div></div>
<div class="paragraph"><p>This fills out the most common elements of a Cj server response. They include:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
The top-level properties: <tt>href</tt> and +version
</p>
</li>
<li>
<p>
The top-level <tt>links</tt> array
</p>
</li>
<li>
<p>
The <tt>items</tt> array
</p>
</li>
<li>
<p>
The <tt>queries</tt> array, and
</p>
</li>
<li>
<p>
The <tt>template</tt> object
</p>
</li>
</ol></div>
<div class="sect3">
<h4 id="_but_what_if_there_is_only_one_tt_item_tt">But What if there is only One <tt>Item</tt>?</h4>
<div class="paragraph"><p>It is important to keep in mind that <strong>all</strong> Cj responses are sent as <em>collections</em>. There is no special representation for
responses that contain only one <tt>item</tt>. For example, if a client application activated the <tt>href</tt> property for the
first <tt>item</tt> in the list (<a href="http://localhost:1337/mildred">http://localhost:1337/mildred</a>), the server should response should look like this:</p></div>
<div class="listingblock">
<div class="title">Valid Cj Server Response when there is only One <tt>Item</tt></div>
<div class="content">
<pre><tt>200 OK HTTP/1.1
Content-Type: application/vnd.collection+json
Length: XXX

{
  collection: {
    version: "1.0",
    href: "http://localhost:1337/mildred",
    links: [
      {
        rel: "home",
        href: "http://localhost:1337"
      }
    ],
    items: [
      {
        href: "http://localhost:1337/mildred",
        data: [
          {
            name: "name",
            value: "mildred",
            prompt: "name"
          },
          {
            name: "email",
            value: "mildred@example.com",
            prompt: "email"
          }
        ],
        links: [
          {
            rel: "alternate",
            href: "http://example.com/blogs/mildred",
            prompt: "blog"
          }
        ]
      }
    ],
    queries: [
      // queries go here...
    ],
    template: {
      data: [
        {
          name: "name",
          value: "",
          prompt: "Name"
        },
        {
          name: "email",
          value: "",
          prompt: "Email"
        },
        {
          name: "blog",
          value: "",
          prompt: "Blog"
        }
      ]
    }
  }
}</tt></pre>
</div></div>
<div class="paragraph"><p>Note that the response still begins with <tt>collection</tt> and includes all the other elements of a valid Cj response.</p></div>
<div class="paragraph"><p>There is one more important part of a valid Cj server response to cover in this tutorial: the <tt>error</tt> object.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_part_5_reporting_errors_to_the_client">Part 5: Reporting Errors to the Client</h3>
<div class="paragraph"><p>In cases where the client has sent an invalid request or the server has a
problem handling the request, you can return a Cj response with an <tt>error</tt>
element. This is a standard way to communicate error details (beyond the
basic protocol information like 404, 410, etc.) to clients.</p></div>
<div class="paragraph"><p>When the server wants to report an error to the client, the response should include the <tt>error</tt> object populated
with server-specific information that will help the client (or the human driveing the client) to recognize
the problem and, if possible, make adjustments and try the request again. The Cj documentation for the
<a href="http://amundsen.com/media-types/collection/format/#objects-error">Error Object</a> says that it looks like this:</p></div>
<div class="listingblock">
<div class="title">The Cj <tt>error</tt> Object</div>
<div class="content">
<pre><tt>"error" :
{
  "title" : STRING,
  "code" : STRING,
  "message" : STRING
}</tt></pre>
</div></div>
<div class="paragraph"><p>Servers can use the three properties to hold details about the error and even instructions on how clients can
resolve the problem and try again. For example, if the client application attempts to update an <tt>item</tt> that does
not exist, the error response might look like this:</p></div>
<div class="listingblock">
<div class="title">A Server Response that includes the Cj <tt>error</tt> Object</div>
<div class="content">
<pre><tt>404 Not Found HTTP/1.1
Content-Type: application/vnd.collection+json
Length: XXX

{
  collection: {
    version: "1.0",
    href: "http://localhost:1337/mildred",
    links: [
      {
        rel: "home",
        href: "http://localhost:1337"
      }
    ],
    "error" : {
      "title" : "Unable to update item",
      "code" : "Internal Error Code x084D",
      "message" : "That item does not exist. Check the URL and try again."
    }
  }
}</tt></pre>
</div></div>
<div class="paragraph"><p>Note that, like all other Cj responses, the Error Response is a complete Cj document starting with the <tt>collection</tt> element. It is valid, by the way, to return other response elements including <tt>links</tt>, <tt>items</tt>, <tt>queries</tt>, and <tt>template</tt>.
It is up to the server to decide which elements will be returned. It is the client&#8217;s responsibility to make sure to
look for, and recognize, the <tt>error</tt> object when it appears in a response.</p></div>
</div>
<div class="sect2">
<h3 id="_summary">Summary</h3>
<div class="paragraph"><p>In this tutorial you learned how a server can create a valid Cj response by working through a step-by-step process
that includes:</p></div>
<div class="ulist"><ul>
<li>
<p>
Creating an internal Cj template as a skeleton or guide for emitting responses
</p>
</li>
<li>
<p>
Adding the <tt>items</tt> array by mapping internal stored data to Cj <tt>items</tt>
</p>
</li>
<li>
<p>
Adding optional machine-readable <tt>queries</tt> that describe ways clients can make additional requests to the server
</p>
</li>
<li>
<p>
Adding an optional Write Template (<tt>template</tt>) that describes how clients can fashion a create (POST) or update (PUT) request to the server, and
</p>
</li>
<li>
<p>
Reporting errors to the client using the Cj <tt>error</tt> object.
</p>
</li>
</ul></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2013-10-11 18:00:45 EDT
</div>
</div>
</body>
</html>
